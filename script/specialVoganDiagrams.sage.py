

# This file was *autogenerated* from the file /home/alice/special-vogan-diagrams/script/specialVoganDiagrams.sage
from sage.all_cmdline import *   # import sage library

_sage_const_10 = Integer(10); _sage_const_1 = Integer(1); _sage_const_36 = Integer(36); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8)
import argparse

'''
   This algorithm provides adjoint orbits of simple Lie groups admitting 
   a canonical special locally homogeneous compatible almost-complex structure.
   For the details, see https://link.springer.com/article/10.1007/s00209-022-02995-9.
   The Lie algebra of the orbit is computed using the theorems in the paper "Equivalence classes of Vogan diagrams", https://www.sciencedirect.com/science/article/pii/S0021869303007269

   Copyright (C) 2022  Alice Gatti

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
'''

if __name__ == "__main__":
	parser = argparse.ArgumentParser(
		formatter_class=argparse.ArgumentDefaultsHelpFormatter)
	parser.add_argument(
		"--type",
		default='A',
		help="Lie type of the Lie algebra",
		type=str)
	parser.add_argument(
		"--rank",
		default=_sage_const_10 ,
		help="Rank of the Lie algebra",
		type=int)
		
	args = parser.parse_args()

	lieType = args.type
	rank = args.rank

	print(DynkinDiagram([lieType,rank]))
	W=WeylGroup([lieType,rank],implementation='permutation')
	positiveRoots=W.positive_roots()	# Positive roots
	C=CartanMatrix([lieType,rank])	# Cartan matrix of the Lie algebra   
	if lieType=='F':	# Scalar product induced on the roots
		B=(_sage_const_1 /_sage_const_36 )*matrix([[_sage_const_4 ,-_sage_const_2 ,_sage_const_0 ,_sage_const_0 ],[-_sage_const_2 ,_sage_const_4 ,-_sage_const_2 ,_sage_const_0 ],[_sage_const_0 ,-_sage_const_2 ,_sage_const_2 ,-_sage_const_1 ],[_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ,_sage_const_2 ]])
	else: 
		B=matrix(QQ,gap('BilinearFormMat(RootSystem(SimpleLieAlgebra("'+lieType+'",'+str(rank)+',Rationals)))'))	
	print("Dimension:",_sage_const_2 *len(positiveRoots)+rank)
	print('  ')
	for P in [q for q in Combinations(range(rank)) if q!=[]]:
		compactroots=[root for root in positiveRoots if sum(root[k] for k in P)%_sage_const_2 ==_sage_const_0 ]	# Compact roots
		noncompactroots=[root for root in positiveRoots if sum(root[k] for k in P)%_sage_const_2 !=_sage_const_0 ]	# Non-compact roots
		epsilon={root: (_sage_const_1  if root in noncompactroots else -_sage_const_1 ) for root in positiveRoots}	# Compactness coefficient
		eta=-_sage_const_2 *sum(epsilon[alpha]*alpha for alpha in positiveRoots)	# Eta vector
		phi0=(C)*(eta-_sage_const_2 *sum(root for root in positiveRoots if all(root[k]==_sage_const_0  for k in P)))	# phi0 vector
		isSpecial=_sage_const_1 
		if all(phi0[k]==_sage_const_0  for k in range(len(phi0))):	# If phi0 is 0, then the orbit is symplectic Calabi-Yau
			print([var('t'+str(k)) if k in P else _sage_const_0  for k in range(len(phi0))],' for all ti>0     Non-compact simple roots:',P,'  ','symplectic Calabi-Yau')
			print("Dimension V:",(_sage_const_2 *sum(all(root[k]==_sage_const_0  for k in P) for root in positiveRoots)+rank),"    Dimension G/V:",_sage_const_2 *(len(positiveRoots)-sum(all(root[k]==_sage_const_0  for k in P) for root in positiveRoots)))
			print("Hermitian scalar curvature:",_sage_const_0 )
			isSpecial=_sage_const_0 
		elif [sgn(phi0[k]) for k in range(len(phi0))]==[-_sage_const_1  if k in P else _sage_const_0  for k in range(len(phi0))]:	# If phi0 has negative entries in correspondence of posnoncomproot, then the orbit
			Omega0=[root for root in Set(positiveRoots).difference(Set([root for root in positiveRoots if all(root[k]==_sage_const_0  for k in P)]))]	# is sympl. general type
			Omega0nc=[root for root in Set(Omega0).intersection(Set(noncompactroots))]
			typeOrbit=''
			if len(P)>_sage_const_1 :
				typeOrbit='symplectic general type'
			else:
				for alpha in Omega0nc:
					for beta in Omega0nc:
						if alpha+beta in Omega0:
							typeOrbit='symplectic general type'
							break
				if typeOrbit!='symplectic general type':
					typeOrbit='general type'
			print(-phi0/(gcd(phi0))	,'   ','Non-compact simple roots:',P,'   ',typeOrbit)
			print("Dimension V:",(_sage_const_2 *(len(positiveRoots)-len(Omega0))+rank),"    Dimension G/V:",_sage_const_2 *len(Omega0))
			print("Hermitian scalar curvature:",_sage_const_4 *gcd(phi0)*sum(sum(epsilon[alpha]*((alpha*B*beta)/(sum(phi0[z]*beta[z]*B[z,z] for z in range(rank)))) for alpha in Omega0) for beta in Omega0))
			isSpecial=_sage_const_0 
		elif [sgn(phi0[k]) for k in range(len(phi0))]==[_sage_const_1  if k in P else _sage_const_0  for k in range(len(phi0))]:	# If phi0 has positive entries in correspondence of posnoncomproot, then the orbit
			T=Combinations([i for i in range(rank) if i not in P])					# is symplectic Fano e there may be more orbits with this diagram
			for i in range(T.cardinality()):
				S=T[i]+P
				phi=(C)*(eta-_sage_const_2 *sum(root for root in positiveRoots if all(root[k]==_sage_const_0  for k in S)))
				if [sgn(phi[k]) for k in range(len(phi))]==[_sage_const_1  if k in S else _sage_const_0  for k in range(len(phi))]:
					print(phi*(_sage_const_1 /gcd(phi)),'   ','Non-compact simple roots:',P,'   ','S:',S,'   ','symplectic Fano')
					Omega=[root for root in Set(positiveRoots).difference(Set([root for root in positiveRoots if all(root[k]==_sage_const_0  for k in S)]))]
					print("Dimension V:",(_sage_const_2 *(len(positiveRoots)-len(Omega))+rank),"    Dimension G/V:",_sage_const_2 *len(Omega))
					print("Hermitian scalar curvature:",-_sage_const_4 *gcd(phi)*sum(sum(epsilon[alpha]*((alpha*B*beta)/(sum(phi[z]*beta[z]*B[z,z] for z in range(rank)))) for alpha in Omega) for beta in Omega))
					# Lie algebra of the orbit
					if lieType=='A':
						equivclass=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
						if equivclass<=((rank+_sage_const_1 )/_sage_const_2 ).floor():
							eqclass=equivclass
						else:
							eqclass=rank+_sage_const_1 -equivclass
						print('Lie algebra: su('+str(eqclass)+','+str(rank+_sage_const_1 -eqclass)+')')
					elif lieType=='B':
						eqclass=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
						print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass+_sage_const_1 )+')')
					elif lieType=='C':
						if rank-_sage_const_1  in P:
							print('Lie algebra: sp('+str(rank)+',R)')
						else:
							N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
							if N<= rank/_sage_const_2 :
								eqclass=N
							else:
								eqclass=rank-N
							print('Lie algebra: sp('+str(eqclass)+','+str(rank-eqclass)+')')
					elif lieType=='D':	
						if (rank-_sage_const_2  in P and rank-_sage_const_1  not in P) or (rank-_sage_const_2  not in P and rank-_sage_const_1  in P) :
							print('Lie algebra: so*('+str(_sage_const_2 *rank)+')')
						elif Set([rank-_sage_const_2 ,rank-_sage_const_1 ]) in P:
							N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)-_sage_const_1 ))
							if N<=rank/_sage_const_2 :
								eqclass=N-_sage_const_1 
							else:
								eqclass=rank-N-_sage_const_1 
							print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass)+')')
						else:
							N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
							if N<=rank/_sage_const_2 :
								eqclass=N
							else:
								eqclass=rank-N
							print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass)+')')
					elif lieType=='G':
						print('Lie algebra: g2(2)')
					elif lieType=='F':
						if Set(P).intersection(Set([_sage_const_0 ,_sage_const_1 ]))!=Set([]):
							print('Lie algebra: f4(4)')
						else:
							print('Lie algebra: f4(-20)')
					elif lieType=='E' and rank==_sage_const_6 :
						II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
						JJ=[j for j in P if j>_sage_const_3 ]
						if _sage_const_1  in P:
							s=_sage_const_1 
						else:
							s=_sage_const_0 
						if II!=[] or JJ!=[]:
							if II!=[] and _sage_const_0  not in II:
								I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
							elif _sage_const_0  in II:
								I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
							else:
								I=_sage_const_0 
							J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
							print(I,J)
							if P==[_sage_const_0 ] or P==[_sage_const_5 ] or P==[_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_3 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_4 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ] or (len(JJ)!=_sage_const_1  and J==_sage_const_2 -I and (I+s)%_sage_const_2 ==_sage_const_1 ) or (len(JJ)!=_sage_const_1  and J==_sage_const_4 -I and (I+s)%_sage_const_2 ==_sage_const_0 ) or (len(JJ)!=_sage_const_1  and J==_sage_const_1 -I) or (len(JJ)==_sage_const_1  and ((J==_sage_const_4 +I and (I+s)%_sage_const_2 ==_sage_const_1 ) or J==_sage_const_1 +I)):
								print('Lie algebra: e6(-14)')
							else:
								print('Lie algebra: e6(2)')				
						else: 
							print('Lie algebra: e6(2)')
					elif lieType=='E' and rank==_sage_const_7 :
						II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
						JJ=[j for j in P if j>_sage_const_3 ]
						if _sage_const_1  in P:
							s=_sage_const_1 
						else:
							s=_sage_const_0 
						if II!=[] or JJ!=[]:
							if II!=[] and _sage_const_0  not in II:
								I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
							elif _sage_const_0  in II:
								I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
							else:
								I=_sage_const_0 
							J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
							if P==[_sage_const_0 ] or P==[_sage_const_3 ] or P==[_sage_const_5 ] or P==[_sage_const_3 ,_sage_const_5 ] or P==[_sage_const_3 ,_sage_const_4 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_4 ] or P==[_sage_const_1 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ,_sage_const_3 ,_sage_const_4 ] or (len(JJ)!=_sage_const_1  and (((J==_sage_const_1 -I or J==_sage_const_3 -I) and (I+s)%_sage_const_2 ==_sage_const_1 ) or ((J==_sage_const_2 -I or J==_sage_const_4 -I) and (I+s)%_sage_const_2 ==_sage_const_0 ) )) or (len(JJ)==_sage_const_1  and (((J==_sage_const_1 +I or J==_sage_const_2 +I or J==_sage_const_3 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_0 ) or (J==_sage_const_4 +I and (I+s)%_sage_const_2 ==_sage_const_1 ))):
								print('Lie algebra: e7(-5)')
							elif P==[_sage_const_6 ] or P==[_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_3 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_4 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_6 ] or (len(JJ)!=_sage_const_1  and ((J==_sage_const_1 -I and (I+s)%_sage_const_2 ==_sage_const_0 ) or (J==_sage_const_2 -I and (I+s)%_sage_const_2 ==_sage_const_1 ))) or (len(JJ)==_sage_const_1  and ((J==_sage_const_1 +I or J==_sage_const_2 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_1 )):
								print('Lie algebra: e7(-25)')	
							else:
								print('Lie algebra: e7(7)')			
						else: 
							print('Lie algebra: e7(7)')
					elif lieType=='E' and rank==_sage_const_8 :
						II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
						JJ=[j for j in P if j>_sage_const_3 ]
						if _sage_const_1  in P:
							s=_sage_const_1 
						else:
							s=_sage_const_0 
						if II!=[] or JJ!=[]:
							if II!=[] and _sage_const_0  not in II:
								I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
							elif _sage_const_0  in II:
								I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
							else:
								I=_sage_const_0 
							J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
							if P==[_sage_const_7 ] or P==[_sage_const_2 ] or P==[_sage_const_3 ] or P==[_sage_const_0 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_6 ] or (len(JJ)!=_sage_const_1  and ((J==_sage_const_1 -I or J==_sage_const_5 -I) and (I+s)%_sage_const_2 ==_sage_const_0 )) or (len(JJ)!=_sage_const_1  and (J==_sage_const_3 -I and (I+s)%_sage_const_2 ==_sage_const_1 )) or (len(JJ)!=_sage_const_1  and (J==_sage_const_2 -I or J==_sage_const_6 -I)) or (len(JJ)==_sage_const_1  and ((J==_sage_const_1 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_1 )) or (len(JJ)==_sage_const_1  and ((J==_sage_const_3 +I and (I+s)%_sage_const_2 ==_sage_const_0 ) or J==_sage_const_2 +I or J==_sage_const_6 +I)):
								print('Lie algebra: e8(-24)')
							else:
								print('Lie algebra: e8(8)')					
						else: 
							print('Lie algebra: e8(8)')
					# Lie algebra of the stabilizer
					if len(P)<rank:
						st=str(CartanType([lieType,rank]).subtype([i+_sage_const_1  for i in range(rank) if i not in P])).translate({ord('['):None,ord("'"):None,ord(','):None,ord(']'):None,ord(' '):None})
						stab=''
						for i in range(len(st)):
							if st[i] in ['A','B','C','D','E']:
								if st[i]=='A':
									stab=stab+'su('
									for j in range(i+_sage_const_1 ,len(st)):
										if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
											if j==len(st)-_sage_const_1 :
												stab=stab+str(int(st[i+_sage_const_1 :len(st)])+_sage_const_1 )+') x '
												break
											else:
												stop=j
												stab=stab+str(int(st[i+_sage_const_1 :stop])+_sage_const_1 )+') x ' 
												break
								if st[i]=='B':
									stab=stab+'so('
									for j in range(i,len(st)):
										if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
											if j==len(st)-_sage_const_1 :
												stab=stab+str(int(st[i+_sage_const_1 :len(st)])*_sage_const_2 +_sage_const_1 )+') x '
												break
											else:
												stop=j
												stab=stab+str(int(st[i+_sage_const_1 :stop])*_sage_const_2 +_sage_const_1 )+') x ' 
												break
								if st[i]=='C':
									stab=stab+'sp('
									for j in range(i,len(st)):
										if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
											if j==len(st)-_sage_const_1 :
												stab=stab+str(int(st[i+_sage_const_1 :len(st)]))+') x '
												break
											else:
												stop=j
												stab=stab+str(int(st[i+_sage_const_1 :stop]))+') x ' 
												break
								if st[i]=='D':
									stab=stab+'so('
									for j in range(i,len(st)):
										if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
											if j==len(st)-_sage_const_1 :
												stab=stab+str(int(st[i+_sage_const_1 :len(st)])*_sage_const_2 )+') x '
												break
											else:
												stop=j
												stab=stab+str(int(st[i+_sage_const_1 :stop])*_sage_const_2 )+') x ' 
												break
								if st[i]=='E':
									if st[i+_sage_const_1 ]=='6':
										stab=stab+'e6 x '
									if st[i+_sage_const_1 ]=='7':
										stab=stab+'e7 x '
						print('Stabilizer: '+stab[:-_sage_const_2 ]+' x R'+str(len(P))+'\n')
					else:
						print('Stabilizer: R'+str(len(P))+'\n')
						
		# Compute the Lie algebra of the orbit in the case symplectic Calabi-Yau and symplectic general type
		if isSpecial==_sage_const_0 :
			# Compute the Lie algebra of the orbit
			if lieType=='A':
				equivclass=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
				if equivclass<=((rank+_sage_const_1 )/_sage_const_2 ).floor():
					eqclass=equivclass
				else:
					eqclass=rank+_sage_const_1 -equivclass
				print('Lie algebra: su('+str(eqclass)+','+str(rank+_sage_const_1 -eqclass)+')')
			elif lieType=='B':
				eqclass=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
				print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass+_sage_const_1 )+')')
			elif lieType=='C':
				if rank-_sage_const_1  in P:
					print('Lie algebra: sp('+str(rank)+',R)')
				else:
					N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
					if N<= rank/_sage_const_2 :
						eqclass=N
					else:
						eqclass=rank-N
					print('Lie algebra: sp('+str(eqclass)+','+str(rank-eqclass)+')')
			elif lieType=='D':	
				if (rank-_sage_const_2  in P and rank-_sage_const_1  not in P) or (rank-_sage_const_2  not in P and rank-_sage_const_1  in P) :
					print('Lie algebra: so*('+str(_sage_const_2 *rank)+')')
				elif Set([rank-_sage_const_2 ,rank-_sage_const_1 ]) in P:
					N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)-_sage_const_1 ))
					if N<=rank/_sage_const_2 :
						eqclass=N-_sage_const_1 
					else:
						eqclass=rank-N-_sage_const_1 
					print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass)+')')
				else:
					N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
					if N<=rank/_sage_const_2 :
						eqclass=N
					else:
						eqclass=rank-N
					print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass)+')')
			elif lieType=='G':
				print('Lie algebra: g2(2)')
			elif lieType=='F':
				if Set(P).intersection(Set([_sage_const_0 ,_sage_const_1 ]))!=Set([]):
					print('Lie algebra: f4(4)')
				else:
					print('Lie algebra: f4(-20)')
			elif lieType=='E' and rank==_sage_const_6 :
				II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
				JJ=[j for j in P if j>_sage_const_3 ]
				if _sage_const_1  in P:
					s=_sage_const_1 
				else:
					s=_sage_const_0 
				if II!=[] or JJ!=[]:
					if II!=[] and _sage_const_0  not in II:
						I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
					elif _sage_const_0  in II:
						I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
					else:
						I=_sage_const_0 
					J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
					print(I,J)
					if P==[_sage_const_0 ] or P==[_sage_const_5 ] or P==[_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_3 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_4 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ] or (len(JJ)!=_sage_const_1  and J==_sage_const_2 -I and (I+s)%_sage_const_2 ==_sage_const_1 ) or (len(JJ)!=_sage_const_1  and J==_sage_const_4 -I and (I+s)%_sage_const_2 ==_sage_const_0 ) or (len(JJ)!=_sage_const_1  and J==_sage_const_1 -I) or (len(JJ)==_sage_const_1  and ((J==_sage_const_4 +I and (I+s)%_sage_const_2 ==_sage_const_1 ) or J==_sage_const_1 +I)):
						print('Lie algebra: e6(-14)')
					else:
						print('Lie algebra: e6(2)')				
				else: 
					print('Lie algebra: e6(2)')
			elif lieType=='E' and rank==_sage_const_7 :
				II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
				JJ=[j for j in P if j>_sage_const_3 ]
				if _sage_const_1  in P:
					s=_sage_const_1 
				else:
					s=_sage_const_0 
				if II!=[] or JJ!=[]:
					if II!=[] and _sage_const_0  not in II:
						I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
					elif _sage_const_0  in II:
						I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
					else:
						I=_sage_const_0 
					J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
					if P==[_sage_const_0 ] or P==[_sage_const_3 ] or P==[_sage_const_5 ] or P==[_sage_const_3 ,_sage_const_5 ] or P==[_sage_const_3 ,_sage_const_4 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_4 ] or P==[_sage_const_1 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ,_sage_const_3 ,_sage_const_4 ] or (len(JJ)!=_sage_const_1  and (((J==_sage_const_1 -I or J==_sage_const_3 -I) and (I+s)%_sage_const_2 ==_sage_const_1 ) or ((J==_sage_const_2 -I or J==_sage_const_4 -I) and (I+s)%_sage_const_2 ==_sage_const_0 ) )) or (len(JJ)==_sage_const_1  and (((J==_sage_const_1 +I or J==_sage_const_2 +I or J==_sage_const_3 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_0 ) or (J==_sage_const_4 +I and (I+s)%_sage_const_2 ==_sage_const_1 ))):
						print('Lie algebra: e7(-5)')
					elif P==[_sage_const_6 ] or P==[_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_3 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_4 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_6 ] or (len(JJ)!=_sage_const_1  and ((J==_sage_const_1 -I and (I+s)%_sage_const_2 ==_sage_const_0 ) or (J==_sage_const_2 -I and (I+s)%_sage_const_2 ==_sage_const_1 ))) or (len(JJ)==_sage_const_1  and ((J==_sage_const_1 +I or J==_sage_const_2 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_1 )):
						print('Lie algebra: e7(-25)')	
					else:
						print('Lie algebra: e7(7)')			
				else: 
					print('Lie algebra: e7(7)')
			elif lieType=='E' and rank==_sage_const_8 :
				II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
				JJ=[j for j in P if j>_sage_const_3 ]
				if _sage_const_1  in P:
					s=_sage_const_1 
				else:
					s=_sage_const_0 
				if II!=[] or JJ!=[]:
					if II!=[] and _sage_const_0  not in II:
						I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
					elif _sage_const_0  in II:
						I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
					else:
						I=_sage_const_0 
					J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
					if P==[_sage_const_7 ] or P==[_sage_const_2 ] or P==[_sage_const_3 ] or P==[_sage_const_0 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_6 ] or (len(JJ)!=_sage_const_1  and ((J==_sage_const_1 -I or J==_sage_const_5 -I) and (I+s)%_sage_const_2 ==_sage_const_0 )) or (len(JJ)!=_sage_const_1  and (J==_sage_const_3 -I and (I+s)%_sage_const_2 ==_sage_const_1 )) or (len(JJ)!=_sage_const_1  and (J==_sage_const_2 -I or J==_sage_const_6 -I)) or (len(JJ)==_sage_const_1  and ((J==_sage_const_1 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_1 )) or (len(JJ)==_sage_const_1  and ((J==_sage_const_3 +I and (I+s)%_sage_const_2 ==_sage_const_0 ) or J==_sage_const_2 +I or J==_sage_const_6 +I)):
						print('Lie algebra: e8(-24)')
					else:
						print('Lie algebra: e8(8)')					
				else: 
					print('Lie algebra: e8(8)')
			# Compute the Lie algebra of the stabilizer
			if len(P)<rank:
				st=str(CartanType([lieType,rank]).subtype([i+_sage_const_1  for i in range(rank) if i not in P])).translate({ord('['):None,ord("'"):None,ord(','):None,ord(']'):None,ord(' '):None})
				stab=''
				for i in range(len(st)):
					if st[i] in ['A','B','C','D','E']:
						if st[i]=='A':
							stab=stab+'su('
							for j in range(i+_sage_const_1 ,len(st)):
								if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
									if j==len(st)-_sage_const_1 :
										stab=stab+str(int(st[i+_sage_const_1 :len(st)])+_sage_const_1 )+') x '
										break
									else:
										stop=j
										stab=stab+str(int(st[i+_sage_const_1 :stop])+_sage_const_1 )+') x ' 
										break
						if st[i]=='B':
							stab=stab+'so('
							for j in range(i,len(st)):
								if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
									if j==len(st)-_sage_const_1 :
										stab=stab+str(int(st[i+_sage_const_1 :len(st)])*_sage_const_2 +_sage_const_1 )+') x '
										break
									else:
										stop=j
										stab=stab+str(int(st[i+_sage_const_1 :stop])*_sage_const_2 +_sage_const_1 )+') x ' 
										break
						if st[i]=='C':
							stab=stab+'sp('
							for j in range(i,len(st)):
								if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
									if j==len(st)-_sage_const_1 :
										stab=stab+str(int(st[i+_sage_const_1 :len(st)]))+') x '
										break
									else:
										stop=j
										stab=stab+str(int(st[i+_sage_const_1 :stop]))+') x ' 
										break
						if st[i]=='D':
							stab=stab+'so('
							for j in range(i,len(st)):
								if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
									if j==len(st)-_sage_const_1 :
										stab=stab+str(int(st[i+_sage_const_1 :len(st)])*_sage_const_2 )+') x '
										break
									else:
										stop=j
										stab=stab+str(int(st[i+_sage_const_1 :stop])*_sage_const_2 )+') x ' 
										break
						if st[i]=='E':
							if st[i+_sage_const_1 ]=='6':
								stab=stab+'e6 x '
							if st[i+_sage_const_1 ]=='7':
								stab=stab+'e7 x '
				print('Stabilizer: '+stab[:-_sage_const_2 ]+' x R'+str(len(P))+'\n')
			else:
				print('Stabilizer: R'+str(len(P))+'\n')

	print('Time:',cputime())

