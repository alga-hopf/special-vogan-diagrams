'''
   This algorithm checks if a given adjoint orbits is special.
   For the details, see ....
   This is the SageMath version.

   Copyright (C) 2022  Alice Gatti

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
'''


# This file was *autogenerated* from the file /home/alice/special-vogan-diagrams/script/specialCombinatoricsVD.sage
from sage.all_cmdline import *   # import sage library

_sage_const_10 = Integer(10); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_25 = Integer(25); _sage_const_36 = Integer(36); _sage_const_4 = Integer(4); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8)

import numpy as np
import time
import argparse

if __name__ == "__main__":
	parser = argparse.ArgumentParser(
		formatter_class=argparse.ArgumentDefaultsHelpFormatter)
	parser.add_argument(
		"--type",
		default='A',
		help="Lie type of the Lie algebra",
		type=str)
	parser.add_argument(
		"--rank",
		default=_sage_const_10 ,
		help="Rank of the Lie algebra",
		type=int)
	parser.add_argument(
		"--s",
		default=[_sage_const_1 ],
		help="Indices of painted nodes (starting from 1)",
		type=int,nargs='+')
	parser.add_argument(
		"--cores",
		default='1',
		help="Number of cores to be used",
		type=int)

	
	args = parser.parse_args()

	lieType = args.type
	rank = args.rank
	S = args.s
	cores = args.cores

	# Delta function
	def delta(x,y):
		try:
		    x
		    y
		except IndexError:
		    return _sage_const_0 
		if type(y)!=list:
		    y=[y]
		if x in y:
		    return _sage_const_1 
		else:
		    return _sage_const_0 

	# Functions that compute the coefficients for the different types of Lie algebras

	# An
	def tau_an(x,s,n):
		s_ext=[_sage_const_0 ]+s+[n+_sage_const_1 ]
		j=np.argwhere(np.array(s)==x)[_sage_const_0 ][_sage_const_0 ]+_sage_const_1 
		s1=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		s2=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		t1=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		t2=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		return s1+s2-(t1+t2)

	@parallel(cores)
	def xi_coeff_an(x,s,rank):
		s_ext=[_sage_const_0 ]+s+[rank+_sage_const_1 ]
		j=np.argwhere(np.array(s)==x)[_sage_const_0 ][_sage_const_0 ]+_sage_const_1 
		return s_ext[j-_sage_const_1 ]-s_ext[j+_sage_const_1 ]+_sage_const_2 *(tau_an(x,s,rank))

	# Bn
	def tau_bn(x,s,n):
		s_ext=[_sage_const_0 ]+s+[n+_sage_const_1 ]
		j=np.argwhere(np.array(s)==x)[_sage_const_0 ][_sage_const_0 ]+_sage_const_1 
		if x!=rank and s[-_sage_const_1 ]!=x:
		    s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		    s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		    t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		    t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		    s1=_sage_const_2 *s1_an+t1_an+(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )-delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-j)/_sage_const_2 )])
		    s2=s2_an
		    t1=t1_an
		    t2=_sage_const_2 *t2_an+(s_ext[j+_sage_const_1 ]-s_ext[j]-_sage_const_1 )+s2_an-delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ])
		    return s1+s2-(t1+t2)
		elif x!=rank and s[-_sage_const_1 ]==x:
		    s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		    s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		    t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		    t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		    s1=_sage_const_2 *s1_an+t1_an+(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )
		    s2=s2_an
		    t1=t1_an
		    t2=t2_an+s2_an
		    return s1+s2-(t1+t2)
		else:
		    s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		    t2_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		    s1=s1_an+sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(floor((j+_sage_const_1 )/_sage_const_2 )))-_sage_const_1 -delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-j)/_sage_const_2 )])
		    t2=t2_an
		    return _sage_const_2 *(s1-t2)

	@parallel(cores)
	def xi_coeff_bn(x,s,rank):
		s_ext=[_sage_const_0 ]+s+[rank+_sage_const_1 ]
		j=np.argwhere(np.array(s)==x)[_sage_const_0 ][_sage_const_0 ]+_sage_const_1 
		if x==s[-_sage_const_1 ] and x!=rank:
		    return -_sage_const_2 *rank+s_ext[j]+s_ext[j-_sage_const_1 ]+_sage_const_2 *(tau_bn(x,s,rank))
		elif x!=s[-_sage_const_1 ] and x!=rank:
		    return s_ext[j-_sage_const_1 ]-s_ext[j+_sage_const_1 ]+_sage_const_2 *(tau_bn(x,s,rank))
		else:
		    return -_sage_const_2 *rank+_sage_const_2 *s_ext[j-_sage_const_1 ]+_sage_const_2 *(tau_bn(x,s,rank))

	# Cn
	def tau_cn(x,s,rank):
		s_ext=[_sage_const_0 ]+s+[rank+_sage_const_1 ]
		j=np.argwhere(np.array(s)==x)[_sage_const_0 ][_sage_const_0 ]+_sage_const_1 
		if x!=rank-_sage_const_1 :
		    if x!=s[-_sage_const_1 ]:
		        if x!=rank and rank not in s_ext:
		            s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		            s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		            t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		            t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))

		            s1_bn=_sage_const_2 *s1_an+t1_an+(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )-delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-j)/_sage_const_2 )])
		            s2_bn=s2_an
		            t1_bn=t1_an
		            t2_bn=_sage_const_2 *t2_an+(s_ext[j+_sage_const_1 ]-s_ext[j]-_sage_const_1 )+s2_an-delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ])

		            s1=s1_bn+_sage_const_2 -delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-j)/_sage_const_2 )])
		            s2=s2_bn
		            t1=t1_bn
		            t2=t2_bn+_sage_const_2 -delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ])
		            return s1+s2-(t1+t2)

		        elif x!=rank and rank in s_ext:
		            s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		            s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		            t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		            t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		            s1=s1_an+t2_an+(s_ext[j+_sage_const_1 ]-s_ext[j])+s2_an-delta(s_ext[-_sage_const_2 ],s_ext[j+_sage_const_2 *ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ])
		            s2=s2_an
		            t1=t1_an
		            t2=t2_an+s1_an+(s_ext[j]-s_ext[j-_sage_const_1 ])+t1_an-delta(s_ext[-_sage_const_2 ],s_ext[j+_sage_const_2 *ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ])
		            return s1+s2-(t1+t2)
		    else:
		        if x==rank:
		            s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		            t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		            delta_n=s2_an 
		            delta_nm=s2_an+t1_an 
		            return -delta_nm+_sage_const_2 *delta_n
		        else:
		            s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		            s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		            t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		            t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))

		            s1_bn=_sage_const_2 *s1_an+t1_an+(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )
		            s2_bn=s2_an
		            t1_bn=t1_an
		            t2_bn=t2_an+s2_an

		            s1=s1_bn+_sage_const_2 -delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-j)/_sage_const_2 )])
		            s2=s2_bn
		            t1=t1_bn
		            t2=t2_bn

		            return s1+s2-(t1+t2)

		else:
		    if s[-_sage_const_1 ]==x: 
		        t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		        s1=_sage_const_2 +t1_an+(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )
		        t1=t1_an
		        return s1-t1

		    elif s[-_sage_const_1 ]==rank: 
		        s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		        s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		        t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		        t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		        rem=s2_an-t1_an-(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )
		        s1=s2_an+_sage_const_1 
		        t1=t1_an
		        return rem+s1-t1

	@parallel(cores)    
	def xi_coeff_cn(x,s,rank):
		s_ext=[_sage_const_0 ]+s+[rank+_sage_const_1 ]
		j=np.argwhere(np.array(s)==x)[_sage_const_0 ][_sage_const_0 ]+_sage_const_1 
		if x!=rank-_sage_const_1 :
		    if x!=s[-_sage_const_1 ] or x==rank:
		        return s_ext[j-_sage_const_1 ]-s_ext[j+_sage_const_1 ]+_sage_const_2 *(tau_cn(x,s,rank))
		    else:
		        return -_sage_const_2 -(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )-_sage_const_2 *(rank-s_ext[j])+_sage_const_2 *(tau_cn(x,s,rank))
		else:
		    return -_sage_const_3 -s_ext[j]+s_ext[j-_sage_const_1 ]+_sage_const_2 *(tau_cn(x,s,rank))

	# Dn
	def tau_dn(x,s,rank):
		s_ext=[_sage_const_0 ]+s+[rank+_sage_const_1 ]
		j=np.argwhere(np.array(s)==x)[_sage_const_0 ][_sage_const_0 ]+_sage_const_1 
		if x not in range(rank-_sage_const_2 ,rank+_sage_const_1 ):
		    if x!=s[-_sage_const_1 ] and len(set(s).intersection(set([rank-_sage_const_1 ,rank])))==_sage_const_0 :
		        if s_ext[-_sage_const_2 ]==rank:
		            s_ext[-_sage_const_2 ]=rank-_sage_const_1 
		        s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		        s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		        t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		        t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))

		        s1=s1_an+delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-j)/_sage_const_2 )])+t1_an+s1_an-_sage_const_3 *delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-j)/_sage_const_2 )])+(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )
		        s2=s2_an
		        t1=t1_an
		        t2=t2_an+delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ])+s2_an+t2_an-_sage_const_3 *delta(s_ext[-_sage_const_1 ],s_ext[j+_sage_const_2 *ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ])+(s_ext[j+_sage_const_1 ]-s_ext[j]-_sage_const_1 )

		        return s1+s2-(t1+t2)

		    elif x!=s[-_sage_const_1 ] and len(set(s).intersection(set([rank-_sage_const_1 ,rank])))==_sage_const_1 :
		        if s_ext[-_sage_const_2 ]==rank:
		            s_ext[-_sage_const_2 ]=rank-_sage_const_1 
		        s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		        s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		        t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		        t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))

		        s1=s1_an+s2_an+t2_an+(s_ext[j+_sage_const_1 ]-s_ext[j])
		        s2=s2_an
		        t1=t1_an
		        t2=t2_an+t1_an+s1_an+(s_ext[j]-s_ext[j-_sage_const_1 ])-delta(s_ext[-_sage_const_3 ],x)
		        return s1+s2-(t1+t2)

		    elif x!=s[-_sage_const_1 ] and len(set(s).intersection(set([rank-_sage_const_1 ,rank])))==_sage_const_2 : 
		        s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		        s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		        t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		        t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		        s1=t1_an+(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )+s1_an+s1_an-_sage_const_3 +_sage_const_2 *delta(rank,s_ext[j+_sage_const_2 *ceil((len(s)-j)/_sage_const_2 )])
		        s2=s2_an
		        t1=t1_an
		        t2=s2_an+t2_an+(s_ext[j+_sage_const_1 ]-s_ext[j]-_sage_const_1 )+_sage_const_2 *delta(rank,s_ext[j+_sage_const_2 *ceil((len(s)-j-_sage_const_1 )/_sage_const_2 )+_sage_const_1 ])-_sage_const_3 +t2_an
		        return s1+s2-(t1+t2)

		    elif x==s[-_sage_const_1 ]:
		        s1_an=sum(s_ext[j+_sage_const_2 *k]-s_ext[j+_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,ceil((len(s)-j)/_sage_const_2 )+_sage_const_1 ))
		        s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		        t2_an=sum(s_ext[j+_sage_const_2 *k+_sage_const_1 ]-s_ext[j+_sage_const_2 *k] for k in range(_sage_const_1 ,ceil((len(s)-(j+_sage_const_1 ))/_sage_const_2 )+_sage_const_1 ))
		        t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))

		        s1=t1_an+(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )
		        s2=s2_an
		        t1=t1_an
		        t2=s2_an

		        return s1+s2-(t1+t2)
		else:
		    if x==rank-_sage_const_2 :
		        if len(set([rank-_sage_const_1 ,rank]).intersection(set(s)))==_sage_const_0 : 
		            return s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 
		        elif len(set([rank-_sage_const_1 ,rank]).intersection(set(s)))==_sage_const_1 : 
		            s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		            t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		            return _sage_const_1 +_sage_const_2 *s2_an-_sage_const_2 *t1_an-(s_ext[j]-s_ext[j-_sage_const_1 ]-_sage_const_1 )   
		        else:
		            s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		            return s_ext[j]-s_ext[j-_sage_const_1 ]+_sage_const_1 
		    else:          
		        if len(set([rank-_sage_const_1 ,rank]).intersection(set(s)))==_sage_const_1 :
		            s_ext[j]=rank-_sage_const_1 
		            s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		            t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		            return _sage_const_2 *(s2_an-t1_an)
		        else:
		            if s_ext[j]==rank:
		                j=j-_sage_const_1 
		            s2_an=sum(s_ext[j-_sage_const_2 *k+_sage_const_1 ]-s_ext[j-_sage_const_2 *k] for k in range(_sage_const_1 ,floor(j/_sage_const_2 )+_sage_const_1 ))
		            t1_an=sum(s_ext[j-_sage_const_2 *k]-s_ext[j-_sage_const_2 *k-_sage_const_1 ] for k in range(_sage_const_1 ,floor((j+_sage_const_1 )/_sage_const_2 )))
		            return (rank-_sage_const_2 -s_ext[j-_sage_const_1 ])

	@parallel(cores)        
	def xi_coeff_dn(x,s,rank):
		s_ext=[_sage_const_0 ]+s+[rank+_sage_const_1 ]
		j=np.argwhere(np.array(s)==x)[_sage_const_0 ][_sage_const_0 ]+_sage_const_1 
		if x not in range(rank-_sage_const_2 ,rank+_sage_const_1 ):
		    if x!=s[-_sage_const_1 ]:
		        if s_ext[-_sage_const_2 ]==rank-_sage_const_1 :
		            s_ext[-_sage_const_2 ]=rank
		        return s_ext[j-_sage_const_1 ]-s_ext[j+_sage_const_1 ]+_sage_const_2 *(tau_dn(x,s,rank))
		    elif x==s[-_sage_const_1 ]:
		        return -_sage_const_2 *rank+s_ext[j]+s_ext[j-_sage_const_1 ]+_sage_const_1 +_sage_const_2 *(tau_dn(x,s,rank))
		elif x==rank-_sage_const_1  or x==rank:
		    if rank-_sage_const_1  in s and s_ext[j]==rank:
		        j=j-_sage_const_1 
		    return -_sage_const_2 -(_sage_const_2 -delta(rank,s)*delta(rank-_sage_const_1 ,s))*(rank-_sage_const_2 -s_ext[j-_sage_const_1 ])+_sage_const_2 *(tau_dn(x,s,rank))
		else:
		    return -rank+s_ext[j-_sage_const_1 ]+_sage_const_1 -(_sage_const_1 -delta(rank-_sage_const_1 ,s))-(_sage_const_1 -delta(rank,s))+_sage_const_2 *(tau_dn(x,s,rank))

	# Special diagram
	def is_special(rank,s,lieType):
		if lieType=='A':
		    coeff=xi_coeff_an([(l,s,rank) for l in s])
		elif lieType=='B':
		    coeff=xi_coeff_bn([(l,s,rank) for l in s])
		elif lieType=='C':
		    coeff=xi_coeff_cn([(l,s,rank) for l in s])
		elif lieType=='D':
		    coeff=xi_coeff_dn([(l,s,rank) for l in s])
		coeff=list(coeff)
		signs=[]
		for i in range(len(s)):
		    signs.append(sign(list(coeff)[i][-_sage_const_1 ]))
		if len(np.unique(signs))==_sage_const_1 :
		    if signs[_sage_const_0 ]==_sage_const_0 :
		    	return 'Symplectic Calabi-Yau'
		    elif signs[_sage_const_0 ]==_sage_const_1 :
		    	return 'Symplectic Fano'
		    else:
		    	return 'Symplectic general type'
		else:
		    return 'No'
		    
	P=[S[i]-_sage_const_1  for i in range(len(S))]
	isSpecial=_sage_const_1 
	
	if lieType in ['A','B','C','D']:
		print('')
		print(lieType+str(rank))
		if lieType=='A':
			d=rank*(rank+_sage_const_2 )
		elif lieType=='B':
			d=rank*(_sage_const_2 *rank+_sage_const_1 )
		elif lieType=='C':
			d=rank*(_sage_const_2 *rank+_sage_const_1 )
		elif lieType=='D':
			d=rank*(_sage_const_2 *rank-_sage_const_1 )
		print('Dimension:',d)
		print('')
		if rank<_sage_const_25 :
			print(DynkinDiagram([lieType,rank]))
			print('')
		print('Painted nodes:',S)
		print('')
		t0=time.time()
		result=is_special(rank,S,lieType)
		print('Is the diagram special? ',result)
		t1=time.time()-t0
		if result!='No':
			isSpecial=_sage_const_0 
	else:
		print('')
		print(lieType+str(rank))
		W=WeylGroup([lieType,rank],implementation='permutation')
		positiveRoots=W.positive_roots()	# Positive roots
		C=CartanMatrix([lieType,rank])	# Cartan matrix of the Lie algebra   
		if lieType=='F':	# Scalar product induced on the roots
			B=(_sage_const_1 /_sage_const_36 )*matrix([[_sage_const_4 ,-_sage_const_2 ,_sage_const_0 ,_sage_const_0 ],[-_sage_const_2 ,_sage_const_4 ,-_sage_const_2 ,_sage_const_0 ],[_sage_const_0 ,-_sage_const_2 ,_sage_const_2 ,-_sage_const_1 ],[_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ,_sage_const_2 ]])
		else: 
			B=matrix(QQ,gap('BilinearFormMat(RootSystem(SimpleLieAlgebra("'+lieType+'",'+str(rank)+',Rationals)))'))	
		print("Dimension:",_sage_const_2 *len(positiveRoots)+rank)
		print(' ')
		print(DynkinDiagram([lieType,rank]))
		print('')
		print('Painted nodes:',s)
		print('')
		P=[S[i]-_sage_const_1  for i in range(len(S))]
		t0=time.time()
		compactroots=[root for root in positiveRoots if sum(root[k] for k in P)%_sage_const_2 ==_sage_const_0 ]	# Compact roots
		noncompactroots=[root for root in positiveRoots if sum(root[k] for k in P)%_sage_const_2 !=_sage_const_0 ]	# Non-compact roots
		epsilon={root: (_sage_const_1  if root in noncompactroots else -_sage_const_1 ) for root in positiveRoots}	# Compactness coefficient
		eta=-_sage_const_2 *sum(epsilon[alpha]*alpha for alpha in positiveRoots)	# Eta vector
		phi0=(C)*(eta-_sage_const_2 *sum(root for root in positiveRoots if all(root[k]==_sage_const_0  for k in P)))	# phi0 vector
		isSpecial=_sage_const_1 
		if all(phi0[k]==_sage_const_0  for k in range(len(phi0))):
			print('Is the diagram special? Symplectic Calabi-Yau')	# If phi0 is 0, then the orbit is symplectic Calabi-Yau
			isSpecial=_sage_const_0 
		elif [sgn(phi0[k]) for k in range(len(phi0))]==[-_sage_const_1  if k in P else _sage_const_0  for k in range(len(phi0))]:	# If phi0 has negative entries in correspondence of posnoncomproot, then the orbit
			print('Is the diagram special? Symplectic general type')
			isSpecial=_sage_const_0 
		elif [sgn(phi0[k]) for k in range(len(phi0))]==[_sage_const_1  if k in P else _sage_const_0  for k in range(len(phi0))]:	# If phi0 has positive entries in correspondence of posnoncomproot, then the orbit
			print('Is the diagram special? Symplectic Fano')
			isSpecial=_sage_const_0 
		else:
			print('Is the diagram special? No')
		t1=time.time()-t0
		
	# Compute the Lie algebra of the orbit and the stabilizer
	if isSpecial==_sage_const_0 :
		# Compute the Lie algebra of the orbit
		if lieType=='A':
			equivclass=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
			if equivclass<=((rank+_sage_const_1 )/_sage_const_2 ).floor():
				eqclass=equivclass
			else:
				eqclass=rank+_sage_const_1 -equivclass
			print('Lie algebra: su('+str(eqclass)+','+str(rank+_sage_const_1 -eqclass)+')')
		elif lieType=='B':
			eqclass=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
			print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass+_sage_const_1 )+')')
		elif lieType=='C':
			if rank-_sage_const_1  in P:
				print('Lie algebra: sp('+str(rank)+',R)')
			else:
				N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
				if N<= rank/_sage_const_2 :
					eqclass=N
				else:
					eqclass=rank-N
				print('Lie algebra: sp('+str(eqclass)+','+str(rank-eqclass)+')')
		elif lieType=='D':	
			if (rank-_sage_const_2  in P and rank-_sage_const_1  not in P) or (rank-_sage_const_2  not in P and rank-_sage_const_1  in P) :
				print('Lie algebra: so*('+str(_sage_const_2 *rank)+')')
			elif Set([rank-_sage_const_2 ,rank-_sage_const_1 ]) in P:
				N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)-_sage_const_1 ))
				if N<=rank/_sage_const_2 :
					eqclass=N-_sage_const_1 
				else:
					eqclass=rank-N-_sage_const_1 
				print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass)+')')
			else:
				N=sum((-_sage_const_1 )**(len(P)-s)*(P[s-_sage_const_1 ]+_sage_const_1 ) for s in range(_sage_const_1 ,len(P)+_sage_const_1 ))
				if N<=rank/_sage_const_2 :
					eqclass=N
				else:
					eqclass=rank-N
				print('Lie algebra: so('+str(_sage_const_2 *eqclass)+','+str(_sage_const_2 *rank-_sage_const_2 *eqclass)+')')
		elif lieType=='G':
			print('Lie algebra: g2(2)')
		elif lieType=='F':
			if Set(P).intersection(Set([_sage_const_0 ,_sage_const_1 ]))!=Set([]):
				print('Lie algebra: f4(4)')
			else:
				print('Lie algebra: f4(-20)')
		elif lieType=='E' and rank==_sage_const_6 :
			II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
			JJ=[j for j in P if j>_sage_const_3 ]
			if _sage_const_1  in P:
				s=_sage_const_1 
			else:
				s=_sage_const_0 
			if II!=[] or JJ!=[]:
				if II!=[] and _sage_const_0  not in II:
					I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
				elif _sage_const_0  in II:
					I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
				else:
					I=_sage_const_0 
				J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
				print(I,J)
				if P==[_sage_const_0 ] or P==[_sage_const_5 ] or P==[_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_3 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_4 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ] or (len(JJ)!=_sage_const_1  and J==_sage_const_2 -I and (I+s)%_sage_const_2 ==_sage_const_1 ) or (len(JJ)!=_sage_const_1  and J==_sage_const_4 -I and (I+s)%_sage_const_2 ==_sage_const_0 ) or (len(JJ)!=_sage_const_1  and J==_sage_const_1 -I) or (len(JJ)==_sage_const_1  and ((J==_sage_const_4 +I and (I+s)%_sage_const_2 ==_sage_const_1 ) or J==_sage_const_1 +I)):
					print('Lie algebra: e6(-14)')
				else:
					print('Lie algebra: e6(2)')				
			else: 
				print('Lie algebra: e6(2)')
		elif lieType=='E' and rank==_sage_const_7 :
			II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
			JJ=[j for j in P if j>_sage_const_3 ]
			if _sage_const_1  in P:
				s=_sage_const_1 
			else:
				s=_sage_const_0 
			if II!=[] or JJ!=[]:
				if II!=[] and _sage_const_0  not in II:
					I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
				elif _sage_const_0  in II:
					I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
				else:
					I=_sage_const_0 
				J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
				if P==[_sage_const_0 ] or P==[_sage_const_3 ] or P==[_sage_const_5 ] or P==[_sage_const_3 ,_sage_const_5 ] or P==[_sage_const_3 ,_sage_const_4 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_4 ] or P==[_sage_const_1 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ,_sage_const_3 ,_sage_const_4 ] or (len(JJ)!=_sage_const_1  and (((J==_sage_const_1 -I or J==_sage_const_3 -I) and (I+s)%_sage_const_2 ==_sage_const_1 ) or ((J==_sage_const_2 -I or J==_sage_const_4 -I) and (I+s)%_sage_const_2 ==_sage_const_0 ) )) or (len(JJ)==_sage_const_1  and (((J==_sage_const_1 +I or J==_sage_const_2 +I or J==_sage_const_3 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_0 ) or (J==_sage_const_4 +I and (I+s)%_sage_const_2 ==_sage_const_1 ))):
					print('Lie algebra: e7(-5)')
				elif P==[_sage_const_6 ] or P==[_sage_const_2 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_3 ,_sage_const_4 ] or P==[_sage_const_0 ,_sage_const_1 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_4 ,_sage_const_6 ] or P==[_sage_const_1 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_6 ] or (len(JJ)!=_sage_const_1  and ((J==_sage_const_1 -I and (I+s)%_sage_const_2 ==_sage_const_0 ) or (J==_sage_const_2 -I and (I+s)%_sage_const_2 ==_sage_const_1 ))) or (len(JJ)==_sage_const_1  and ((J==_sage_const_1 +I or J==_sage_const_2 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_1 )):
					print('Lie algebra: e7(-25)')	
				else:
					print('Lie algebra: e7(7)')			
			else: 
				print('Lie algebra: e7(7)')
		elif lieType=='E' and rank==_sage_const_8 :
			II=[j for j in P if j<=_sage_const_3  and j!=_sage_const_1 ]
			JJ=[j for j in P if j>_sage_const_3 ]
			if _sage_const_1  in P:
				s=_sage_const_1 
			else:
				s=_sage_const_0 
			if II!=[] or JJ!=[]:
				if II!=[] and _sage_const_0  not in II:
					I=sum((-_sage_const_1 )**(len(II)-a-_sage_const_1 )*(II[a]) for a in range(len(II)))
				elif _sage_const_0  in II:
					I=(-_sage_const_1 )**(len(II)-_sage_const_1 )+sum((-_sage_const_1 )**(len(II)-a)*(II[a]) for a in range(len(II)))
				else:
					I=_sage_const_0 
				J=sum((-_sage_const_1 )**(len(JJ)-a-_sage_const_1 )*(JJ[a]) for a in range(len(JJ)))
				if P==[_sage_const_7 ] or P==[_sage_const_2 ] or P==[_sage_const_3 ] or P==[_sage_const_0 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_2 ] or P==[_sage_const_1 ,_sage_const_5 ] or P==[_sage_const_1 ,_sage_const_6 ] or (len(JJ)!=_sage_const_1  and ((J==_sage_const_1 -I or J==_sage_const_5 -I) and (I+s)%_sage_const_2 ==_sage_const_0 )) or (len(JJ)!=_sage_const_1  and (J==_sage_const_3 -I and (I+s)%_sage_const_2 ==_sage_const_1 )) or (len(JJ)!=_sage_const_1  and (J==_sage_const_2 -I or J==_sage_const_6 -I)) or (len(JJ)==_sage_const_1  and ((J==_sage_const_1 +I or J==_sage_const_5 +I) and (I+s)%_sage_const_2 ==_sage_const_1 )) or (len(JJ)==_sage_const_1  and ((J==_sage_const_3 +I and (I+s)%_sage_const_2 ==_sage_const_0 ) or J==_sage_const_2 +I or J==_sage_const_6 +I)):
					print('Lie algebra: e8(-24)')
				else:
					print('Lie algebra: e8(8)')					
			else: 
				print('Lie algebra: e8(8)')
		# Compute the Lie algebra of the stabilizer
		if len(P)<rank:
			st=str(CartanType([lieType,rank]).subtype([i+_sage_const_1  for i in range(rank) if i not in P])).translate({ord('['):None,ord("'"):None,ord(','):None,ord(']'):None,ord(' '):None})
			stab=''
			for i in range(len(st)):
				if st[i] in ['A','B','C','D','E']:
					if st[i]=='A':
						stab=stab+'su('
						for j in range(i+_sage_const_1 ,len(st)):
							if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
								if j==len(st)-_sage_const_1 :
									stab=stab+str(int(st[i+_sage_const_1 :len(st)])+_sage_const_1 )+') x '
									break
								else:
									stop=j
									stab=stab+str(int(st[i+_sage_const_1 :stop])+_sage_const_1 )+') x ' 
									break
					if st[i]=='B':
						stab=stab+'so('
						for j in range(i,len(st)):
							if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
								if j==len(st)-_sage_const_1 :
									stab=stab+str(int(st[i+_sage_const_1 :len(st)])*_sage_const_2 +_sage_const_1 )+') x '
									break
								else:
									stop=j
									stab=stab+str(int(st[i+_sage_const_1 :stop])*_sage_const_2 +_sage_const_1 )+') x ' 
									break
					if st[i]=='C':
						stab=stab+'sp('
						for j in range(i,len(st)):
							if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
								if j==len(st)-_sage_const_1 :
									stab=stab+str(int(st[i+_sage_const_1 :len(st)]))+') x '
									break
								else:
									stop=j
									stab=stab+str(int(st[i+_sage_const_1 :stop]))+') x ' 
									break
					if st[i]=='D':
						stab=stab+'so('
						for j in range(i,len(st)):
							if st[j]=='r' or st[j]=='x' or j==len(st)-_sage_const_1 :
								if j==len(st)-_sage_const_1 :
									stab=stab+str(int(st[i+_sage_const_1 :len(st)])*_sage_const_2 )+') x '
									break
								else:
									stop=j
									stab=stab+str(int(st[i+_sage_const_1 :stop])*_sage_const_2 )+') x ' 
									break
					if st[i]=='E':
						if st[i+_sage_const_1 ]=='6':
							stab=stab+'e6 x '
						if st[i+_sage_const_1 ]=='7':
							stab=stab+'e7 x '
			print('Stabilizer: '+stab[:-_sage_const_2 ]+' x R'+str(len(P))+'\n')
		else:
			print('Stabilizer: R'+str(len(P))+'\n')
		
		print('Time:',t1)

